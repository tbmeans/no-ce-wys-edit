<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Post Writer</title>
  <style>
    body {
      background-color: #333;
    }
    #main-container {
      background-color: #777;
      margin: 1in 1in;
      min-height: 40rem;
    }
    #main-container:focus {
      background-color: #888;
    }
    #write-space {
      white-space: pre;
      padding: 2rem 2rem;
    }
    @keyframes blinky {
      from {
        color: black;
      }
      to {
        color: gray;
      }
    }
    #cursor {
      animation: 1s infinite blinky;
    }
  </style>
</head>
<body>
  <div id="main-container" tabindex="0">
    <p id="write-space"><span id="cursor">|</span></p>
  </div>
<script>

const mcont = document.getElementById("main-container");
const space = document.getElementById("write-space");
const cursor = document.getElementById("cursor");

mcont.addEventListener("focus", (event) => {
  mcont.addEventListener("keydown", keyfuncs);
});

mcont.addEventListener("blur", (event) => {
  mcont.removeEventListener("keydown", keyfuncs);
});

function getText() {
  const nodes = Array.from(space.childNodes);
  return nodes.length === 3 && [ nodes[0], nodes[2] ] ||
      nodes[0].nodeValue && [ nodes[0], null ] || [ null, nodes[1] ];
}

function charEdit(value) {
  const [ precurs, postcur ] = getText();
  if (value === -1 && precurs) {
    precurs.nodeValue = precurs.nodeValue.slice(0, -1);
  } else if (value === +1 && postcur) {
    postcur.nodeValue = postcur.nodeValue.slice(1);
  } else if (typeof value === "string" && !precurs) {
    space.insertBefore(document.createTextNode(value), cursor);
  } else if (typeof value === "string") {
    precurs.nodeValue = precurs.nodeValue + value;
  }
  // Instead of a separate function to call to clear empty nodes,
  // just clear any empty nodes after edit logic.
  if (postcur && postcur.nodeValue.length === 0) {
    space.removeChild(postcur);
  }
  if (precurs && precurs.nodeValue.length === 0) {
    space.removeChild(precurs);
  }
}

function getChar(textNodeValue, isToTheLeft) {
  const pos = isToTheLeft && -1 || 0;
  return textNodeValue.split('\n').at(pos).at(pos);
}

function getString(textNodeValue, isToTheLeft) {};

function moveCurs(directionKeyName) {
  const dname = directionKeyName.replace("Arrow", '');
  const [ precurs, postcur ] = getText();

  if (precurs && dname === "Left") {
    const char =  getChar(precurs.nodeValue, true);
    charEdit(-1);
    if (postcur) {
      postcur.nodeValue = char + postcur.nodeValue;
    } else {
      space.appendChild(document.createTextNode(char));
    }
  }

  if (precurs && dname === "Up") {
    const str = getString(precurs.nodeValue, true);
  }

  if (postcur && dname === "Right") {
    const char = getChar(postcur.nodeValue, false);
    charEdit(+1);
    charEdit(char);
  }

  if (postcur && dname === "Down") {
    const str = getString(postcur.nodeValue, false);
  }
}

function keyfuncs(event) {
  switch(event.key) {
    case "Backspace":
      charEdit(-1);
      break;
    case "Delete": 
      charEdit(+1);
      break;
    case "Enter":
      charEdit('\n');
      break;
    case "ArrowLeft":
    case "ArrowRight":
    case "ArrowUp":
    case "ArrowDown":
      moveCurs(event.key);
      break;
    case "Tab":
    case "Shift":
    case "Control":
    case "CapsLock":
    case "NumLock":
      break;
    default:
      charEdit(event.key);
  }
}

</script>
</body>
</html>
