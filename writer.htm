<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Post Writer</title>
  <style>
    body {
      background-color: #333;
    }
    #main-container {
      background-color: #777;
      margin: 1in 1in;
      min-height: 40rem;
    }
    #main-container:focus {
      background-color: #888;
    }
    #write-space {
      white-space: pre;
      padding: 2rem 2rem;
    }
    @keyframes blinky {
      from {
        color: black;
      }
      to {
        color: gray;
      }
    }
    #cursor {
      animation: 1s infinite blinky;
    }
  </style>
</head>
<body>
  <div id="main-container" tabindex="0">
    <p id="write-space"><span id="cursor">|</span></p>
  </div>
<script>

const mcont = document.getElementById("main-container");
const space = document.getElementById("write-space");
const cursor = document.getElementById("cursor");

mcont.addEventListener("focus", (event) => {
  mcont.addEventListener("keydown", keyfuncs);
});

mcont.addEventListener("blur", (event) => {
  mcont.removeEventListener("keydown", keyfuncs);
});

function getText() {
  const nodes = Array.from(space.childNodes);
  return nodes.length === 3 && [ nodes[0], nodes[2] ] ||
      nodes[0].nodeValue && [ nodes[0], null ] || [ null, nodes[1] ];
}

function charEdit(value) {
  const [ precurs, postcur ] = getText();
  if (value === -1 && precurs) {
    precurs.nodeValue = precurs.nodeValue.slice(0, -1);
  } else if (value === +1 && postcur) {
    postcur.nodeValue = postcur.nodeValue.slice(1);
  } else if (typeof value === "string" && !precurs) {
    space.insertBefore(document.createTextNode(value), cursor);
  } else if (typeof value === "string") {
    precurs.nodeValue = precurs.nodeValue + value;
  }
  // Instead of a separate function to call to clear empty nodes,
  // just clear any empty nodes after edit logic.
  if (postcur && postcur.nodeValue.length === 0) {
    space.removeChild(postcur);
  }
  if (precurs && precurs.nodeValue.length === 0) {
    space.removeChild(precurs);
  }
}

// THIS NEEDED TO INCLUDE THE NEWLINES AS GETTABLE CHARS RATHER THAN SPLIT THEM AWAY
function getChar(textNodeValue, isToTheLeft) {
  return textNodeValue.at(isToTheLeft && -1 || 0);
}

function moveCurs(directionKeyName) {
  const dname = directionKeyName.replace("Arrow", '');
  const [ precurs, postcur ] = getText();

  if (precurs && dname === "Left") {
    const char = getChar(precurs.nodeValue, true);
    charEdit(-1);
    if (postcur) {
      postcur.nodeValue = char + postcur.nodeValue;
    } else {
      space.appendChild(document.createTextNode(char));
    }
    return;
  }

  if (postcur && dname === "Right") {
    const char = getChar(postcur.nodeValue, false);
    charEdit(+1);
    charEdit(char);
    return;
  }

  // The logic of up and down comes down to shifting characters to
  // opposite side of cursor, dependent especially on the characters
  // from the cursor to the beginning of the line on which the cursor
  // is currently located. 

  const fin = precurs ? precurs.nodeValue.lastIndexOf('\n') + 1 : 0;
  const len = precurs ? precurs.nodeValue.slice(fin).length : 0;

  if (fin === 0 && dname === "Up") {
      return;
    }

  if (dname === "Up") {
    const pen = precurs.nodeValue.slice(0, fin - 1).lastIndexOf('\n') + 1;
    const cutpre = precurs.nodeValue.slice(pen + len);
    precurs.nodeValue = precurs.nodeValue.slice(0, pen + len);
    if (precurs.nodeValue.length === 0) {
      space.removeChild(precurs);
    }
    if (postcur) {
      postcur.nodeValue = cutpre + postcur.nodeValue;
    } else {
      space.appendChild(document.createTextNode(cutpre));
    }
    return;
  }

  // Only case remaining is direction down.

  const ini = postcur ? postcur.nodeValue.indexOf('\n') + 1 : 0;

  if (ini === 0) {
    return;
  }

  const cutpos = postcur.nodeValue.slice(0, ini + len);
  postcur.nodeValue = postcur.nodeValue.slice(ini + len);

  if (postcur.nodeValue.length === 0) {
    space.removeChild(postcur);
  }

  if (precurs) {
    precurs.nodeValue += cutpos;
  } else {
    space.insertBefore(document.createTextNode(cutpos), cursor);
  }
}

function keyfuncs(event) {
  switch(event.key) {
    case "Backspace":
      charEdit(-1);
      break;
    case "Delete": 
      charEdit(+1);
      break;
    case "Enter":
      charEdit('\n');
      break;
    case "ArrowLeft":
    case "ArrowRight":
    case "ArrowUp":
    case "ArrowDown":
      moveCurs(event.key);
      break;
    case "Tab":
    case "Shift":
    case "Control":
    case "CapsLock":
    case "NumLock":
      break;
    default:
      charEdit(event.key);
  }
}

</script>
</body>
</html>
